{"name":"MimeKit","tagline":"A C# MIME creation and parser library with support for S/MIME, PGP and Unix mbox spools.","body":"# MimeKit\r\n\r\n<a href=\"https://scan.coverity.com/projects/3201\">\r\n  <img alt=\"Coverity Scan Build Status\"\r\n       src=\"https://scan.coverity.com/projects/3201/badge.svg\"/>\r\n</a>\r\n\r\n## What is MimeKit?\r\n\r\nMimeKit is a C# library which may be used for the creation and parsing of messages using the Multipurpose Internet Mail Extension (MIME), as defined by [numerous IETF specifications](https://github.com/jstedfast/MimeKit/blob/master/RFCs.md).\r\n\r\n## History\r\n\r\nAs a developer and user of Electronic Mail clients, I had come to realize that the vast majority of email client\r\n(and server) software had less-than-satisfactory MIME implementations. More often than not these email clients\r\ncreated broken MIME messages and/or would incorrectly try to parse a MIME message thus subtracting from the full\r\nbenefits that MIME was meant to provide. MimeKit is meant to address this issue by following the MIME specification\r\nas closely as possible while also providing programmers with an extremely easy to use high-level API.\r\n\r\nThis led me, at first, to implement another MIME parser library called [GMime](http://spruce.sourceforge.net/gmime)\r\nwhich is implemented in C and later added a C# binding called GMime-Sharp.\r\n\r\nNow that I typically find myself working in C# rather than lower level languages like C, I decided to\r\nbegin writing a new parser in C# which would not depend on GMime. This would also allow me to have more\r\nflexibility in that I'd be able use Generics and create a more .NET-compliant API.\r\n\r\n## Performance\r\n\r\nWhile mainstream beliefs may suggest that C# can never be as fast as C, it turns out that with a bit of creative\r\nparser design and a few clever optimizations \r\n<sup>[[1](http://jeffreystedfast.blogspot.com/2013/09/optimization-tips-tricks-used-by.html)]\r\n[[2](http://jeffreystedfast.blogspot.com/2013/10/optimization-tips-tricks-used-by.html)]</sup>, MimeKit's performance\r\nis actually [on par with GMime](http://jeffreystedfast.blogspot.com/2014/03/gmime-gets-speed-boost.html).\r\n\r\nSince GMime is pretty well-known as a high-performance native MIME parser and MimeKit more-or-less matches GMime's\r\nperformance, it stands to reason that MimeKit is likely unsurpassed in performance in the .NET MIME parser space.\r\n\r\nFor a comparison, as I [blogged here](http://jeffreystedfast.blogspot.com/2013/10/optimization-tips-tricks-used-by.html)\r\n(I have since optimized MimeKit by at least another 30%), MimeKit is more than 25x faster than OpenPOP.NET, 75x faster\r\nthan SharpMimeTools, and 65x faster than regex-based parsers. Even the commercial MIME parser offerings such as LimiLabs'\r\nMail.dll and NewtonIdeas' Mime4Net cannot even come close to matching MimeKit's performance (they are both orders of\r\nmagnitude slower than MimeKit).\r\n\r\n## License Information\r\n\r\nMimeKit is Copyright (C) 2012-2014 Xamarin Inc. and is licensed under the MIT license:\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    of this software and associated documentation files (the \"Software\"), to deal\r\n    in the Software without restriction, including without limitation the rights\r\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the Software is\r\n    furnished to do so, subject to the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included in\r\n    all copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n    THE SOFTWARE.\r\n\r\n## Installing via NuGet\r\n\r\nThe easiest way to install MimeKit is via [NuGet](https://www.nuget.org/packages/MimeKit/).\r\n\r\nIn Visual Studio's [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console),\r\nsimply enter the following command:\r\n\r\n    Install-Package MimeKit\r\n\r\n## Building\r\n\r\nFirst, you'll need to clone MimeKit and Bouncy Castle from my GitHub repository:\r\n\r\n    git clone https://github.com/jstedfast/MimeKit.git\r\n    git clone https://github.com/jstedfast/bc-csharp.git\r\n    git clone https://github.com/jstedfast/Portable.Text.Encoding.git\r\n\r\nCurrently, MimeKit depends on the vs2010 branch of bc-csharp for the Visual Studio 2010 project\r\nfiles that I've added (to replace the Visual Studio 2003 project files). To switch to that branch,\r\n\r\n    cd bc-csharp\r\n    git checkout -b vs2010 origin/vs2010\r\n\r\nIn the top-level MimeKit source directory, there are several solution files:\r\n\r\n* MimeKit.sln includes projects for .NET 4.5, .NET 4.0, PCL (Profile7 and Profile111), Xamarin.Android, Xamarin.iOS, and Xamarin.Mac as well as the unit tests.\r\n* MimeKit.Mobile.sln just includes the Xamarin.Android and Xamarin.iOS projects.\r\n* MimeKit.Net40.sln just includes the .NET 4.0 project.\r\n\r\nIf you don't have the Xamarin products, you'll probably want to open the MimeKit.Net40.sln instead of MimeKit.sln.\r\n\r\nOnce you've opened the appropriate MimeKit solution file in either Xamarin Studio or Visual Studio 2010+ (either will work),\r\nyou can simply choose the Debug or Release build configuration and then build.\r\n\r\nNote: The Release build will generate the xml API documentation, but the Debug build will not.\r\n\r\n## Using MimeKit\r\n\r\n### Parsing Messages\r\n\r\nOne of the more common operations that MimeKit is meant for is parsing email messages from arbitrary streams.\r\nThere are two ways of accomplishing this task.\r\n\r\nThe first way is to use one of the `Load()` methods on `MimeKit.MimeMessage`:\r\n\r\n```csharp\r\n// Load a MimeMessage from a stream\r\nvar message = MimeMessage.Load (stream);\r\n```\r\n\r\nThe second way is to use the `MimeParser` class. For the most part, using the `MimeParser` directly is not necessary\r\nunless you wish to parse a Unix mbox file stream. However, this is how you would do it:\r\n\r\n```csharp\r\n// Load a MimeMessage from a stream\r\nvar parser = new MimeParser (stream, MimeFormat.Entity);\r\nvar message = parser.ParseMessage ();\r\n```\r\n\r\nFor Unix mbox file streams, you would use the parser like this:\r\n\r\n```csharp\r\n// Load every message from a Unix mbox\r\nvar parser = new MimeParser (stream, MimeFormat.Mbox);\r\nwhile (!parser.IsEndOfStream) {\r\n    var message = parser.ParseMessage ();\r\n\r\n    // do something with the message\r\n}\r\n```\r\n\r\n### Getting the Body of a Message\r\n\r\nA common misunderstanding about email is that there is a well-defined message body and then a list\r\nof attachments. This is not really the case. The reality is that MIME is a tree structure of content,\r\nmuch like a file system.\r\n\r\nLuckily, MIME does define a set of general rules for how mail clients should interpret this tree\r\nstructure of MIME parts. The `Content-Disposition` header is meant to provide hints to the receiving\r\nclient as to which parts are meant to be displayed as part of the message body and which are meant\r\nto be interpreted as attachments.\r\n\r\nThe `Content-Disposition` header will generally have one of two values: `inline` or `attachment`.\r\n\r\nThe meaning of these value should be fairly obvious. If the value is `attachment`, then the content\r\nof said MIME part is meant to be presented as a file attachment separate from the core message.\r\nHowever, if the value is `inline`, then the content of that MIME part is meant to be displayed inline\r\nwithin the mail client's rendering of the core message body. If the `Content-Disposition` header does\r\nnot exist, then it should be treated as if the value were `inline`.\r\n\r\nTechnically, every part that lacks a `Content-Disposition` header or that is marked as `inline`, then,\r\nis part of the core message body.\r\n\r\nThere's a bit more to it than that, though.\r\n\r\nModern MIME messages will often contain a `multipart/alternative` MIME container which will generally contain\r\na `text/plain` and `text/html` version of the text that the sender wrote. The `text/html` version is typically\r\nformatted much closer to what the sender saw in his or her WYSIWYG editor than the `text/plain` version.\r\n\r\nThe reason for sending the message text in both formats is that not all mail clients are capable of displaying\r\nHTML.\r\n\r\nThe receiving client should only display one of the alternative views contained within the `multipart/alternative`\r\ncontainer. Since alternative views are listed in order of least faithful to most faithful with what the sender\r\nsaw in his or her WYSIWYG editor, the receiving client *should* walk over the list of alternative views starting\r\nat the end and working backwards until it finds a part that it is capable of displaying.\r\n\r\nExample:\r\n```\r\nmultipart/alternative\r\n  text/plain\r\n  text/html\r\n```\r\n\r\nAs seen in the example above, the `text/html` part is listed last because it is the most faithful to\r\nwhat the sender saw in his or her WYSIWYG editor when writing the message.\r\n\r\nTo make matters even more complicated, sometimes modern mail clients will use a `multipart/related`\r\nMIME container instead of a simple `text/html` part in order to embed images and other content\r\nwithin the HTML.\r\n\r\nExample:\r\n```\r\nmultipart/alternative\r\n  text/plain\r\n  multipart/related\r\n    text/html\r\n    image/jpeg\r\n    video/mp4\r\n    image/png\r\n```\r\n\r\nIn the example above, one of the alternative views is a `multipart/related` container which contains\r\nan HTML version of the message body that references the sibling video and images.\r\n\r\nNow that you have a rough idea of how a message is structured and how to interpret various MIME entities,\r\nthe next step is learning how to traverse the MIME tree using MimeKit.\r\n\r\nNote: For your convenience, MimeKit's `MimeMessage` class has two properties that can help you get the\r\n`text/plain` or `text/html` version of the message body. These are `TextBody` and `HtmlBody`,\r\nrespectively.\r\n\r\nKeep in mind, however, that at least with the `HtmlBody` property, it may be that the HTML part is\r\na child of a `multipart/related`, allowing it to refer to images and other types of media that\r\nare also contained within that `multipart/related` entity. This property is really only a convenience\r\nproperty and is not a really good substitute for traversing the MIME structure yourself so that you\r\nmay properly interpret related content.\r\n\r\n### Traversing a MimeMessage\r\n\r\nThe `MimeMessage.Body` is the top-level MIME entity of the message. Generally, it will either be a\r\n`TextPart` or a `Multipart`.\r\n\r\nAs an example, if you wanted to rip out all of the attachments of a message, your code might look\r\nsomething like this:\r\n\r\n```csharp\r\nvar attachments = new List<MimePart> ();\r\nvar multiparts = new List<Multipart> ();\r\nvar iter = new MimeIterator (message);\r\n\r\n// collect our list of attachments and their parent multiparts\r\nwhile (iter.MoveNext ()) {\r\n    var multipart = iter.Parent as Multipart;\r\n    var part = iter.Current as MimePart;\r\n\r\n    if (parent != null && part != null && part.IsAttachment) {\r\n        // keep track of each attachment's parent multipart\r\n        multiparts.Add (multipart);\r\n        attachments.Add (part);\r\n    }\r\n}\r\n\r\n// now remove each attachment from its parent multipart...\r\nfor (int i = 0; i < attachments.Count; i++)\r\n    multiparts[i].Remove (attachments[i]);\r\n```\r\n\r\n### Quick and Dirty Enumeration of Message Body Parts\r\n\r\nIf you would rather skip the proper way of traversing a MIME tree, another option that MimeKit provides\r\nis a simple enumerator over the message's body parts in a flat (depth-first) list.\r\n\r\nYou can access this flat list via the `BodyParts` property, like so:\r\n\r\n```csharp\r\nforeach (var part in message.BodyParts) {\r\n   // do something\r\n}\r\n```\r\n\r\nAnother helper property on the MimeMessage class is the `Attachments` property which works\r\nmuch the same way as the `BodyParts` property except that it will only contain MIME parts\r\nwhich have a `Content-Disposition` header value that is set to `attachment`.\r\n\r\n### Getting the Decoded Content of a MIME Part\r\n\r\nAt some point, you're going to want to extract the decoded content of a `MimePart` (such as an image) and\r\nsave it to disk or feed it to a UI control to display it.\r\n\r\nOnce you've found the `MimePart` object that you'd like to extract the content of, here's how you can\r\nsave the decoded content to a file:\r\n\r\n```csharp\r\n// This will get the name of the file as specified by the sending mail client.\r\n// Note: this value *may* be null, so you'll want to handle that case in your code.\r\nvar fileName = part.FileName;\r\n\r\nusing (var stream = File.Create (fileName)) {\r\n    part.ContentObject.DecodeTo (stream);\r\n}\r\n```\r\n\r\nYou can also get access to the original raw content by \"opening\" the `ContentObject`. This might be useful\r\nif you want to pass the content off to a UI control that can do its own loading from a stream.\r\n\r\n```csharp\r\nusing (var stream = part.ContentObject.Open ()) {\r\n    // At this point, you can now read from the stream as if it were the original,\r\n    // raw content. Assuming you have an image UI control that could load from a\r\n    // stream, you could do something like this:\r\n    imageControl.Load (stream);\r\n}\r\n```\r\n\r\nThere are a number of useful filters that can be applied to a `FilteredStream`, so if you find this type of\r\ninterface appealing, I suggest taking a look at the available filters in the `MimeKit.IO.Filters` namespace\r\nor even write your own! The possibilities are limited only by your imagination.\r\n\r\n### Creating a Simple Message\r\n\r\nCreating MIME messages using MimeKit is really trivial.\r\n\r\n```csharp\r\nvar message = new MimeMessage ();\r\nmessage.From.Add (new MailboxAddress (\"Joey\", \"joey@friends.com\"));\r\nmessage.To.Add (new MailboxAddress (\"Alice\", \"alice@wonderland.com\"));\r\nmessage.Subject = \"How you doin?\";\r\n\r\nmessage.Body = new TextPart (\"plain\") {\r\n    Text = @\"Hey Alice,\r\n\r\nWhat are you up to this weekend? Monica is throwing one of her parties on\r\nSaturday and I was hoping you could make it.\r\n\r\nWill you be my +1?\r\n\r\n-- Joey\r\n\"\r\n};\r\n```\r\n\r\nA `TextPart` is a leaf-node MIME part with a text media-type. The first argument to the `TextPart` constructor\r\nspecifies the media-subtype, in this case, \"plain\". Another media subtype you are probably familiar with\r\nis the \"html\" subtype. Some other examples include \"enriched\", \"rtf\", and \"csv\".\r\n\r\nThe `Text` property is the easiest way to both get and set the string content of the MIME part.\r\n\r\n### Creating a Message with Attachments\r\n\r\nAttachments are just like any other `MimePart`, the only difference is that they typically have\r\na Content-Disposition header with a value of \"attachment\" instead of \"inline\" or no\r\nContent-Disposition header at all.\r\n\r\nTypically, when a mail client adds attachments to a message, it will create a multipart/mixed\r\npart and add the text body part and all of the file attachments to the multipart/mixed.\r\n\r\nHere's how you can do that with MimeKit:\r\n\r\n```csharp\r\nvar message = new MimeMessage ();\r\nmessage.From.Add (new MailboxAddress (\"Joey\", \"joey@friends.com\"));\r\nmessage.To.Add (new MailboxAddress (\"Alice\", \"alice@wonderland.com\"));\r\nmessage.Subject = \"How you doin?\";\r\n\r\n// create our message text, just like before (except don't set it as the message.Body)\r\nvar body = new TextPart (\"plain\") {\r\n    Text = @\"Hey Alice,\r\n\r\nWhat are you up to this weekend? Monica is throwing one of her parties on\r\nSaturday and I was hoping you could make it.\r\n\r\nWill you be my +1?\r\n\r\n-- Joey\r\n\"\r\n};\r\n\r\n// create an image attachment for the file located at path\r\nvar attachment = new MimePart (\"image\", \"gif\") {\r\n    ContentObject = new ContentObject (File.OpenRead (path), ContentEncoding.Default),\r\n    ContentDisposition = new ContentDisposition (ContentDisposition.Attachment),\r\n    ContentTransferEncoding = ContentEncoding.Base64,\r\n    FileName = Path.GetFileName (path)\r\n};\r\n\r\n// now create the multipart/mixed container to hold the message text and the\r\n// image attachment\r\nvar multipart = new Multipart (\"mixed\");\r\nmultipart.Add (body);\r\nmultipart.Add (attachment);\r\n\r\n// now set the multipart/mixed as the message body\r\nmessage.Body = multipart;\r\n```\r\n\r\nOf course, that is just a simple example. A lot of modern mail clients such as Outlook or Thunderbird will \r\nsend out both a text/html and a text/plain version of the message text. To do this, you'd create a `TextPart`\r\nfor the text/plain part and a `TextPart` for the text/html part and then add them to a multipart/alternative\r\nlike so:\r\n\r\n```csharp\r\nvar attachment = CreateAttachment ();\r\nvar plain = CreateTextPlainPart ();\r\nvar html = CreateTextHtmlPart ();\r\n\r\n// Note: it is important that the text/html part is added second, because it is the\r\n// most expressive version and (probably) the most faithful to the sender's WYSIWYG \r\n// editor.\r\nvar alternative = new Multipart (\"alternative\");\r\nalternative.Add (plain);\r\nalternative.Add (html);\r\n\r\n// now create the multipart/mixed container to hold the multipart/alternative\r\n// and the image attachment\r\nvar multipart = new Multipart (\"mixed\");\r\nmultipart.Add (alternative);\r\nmultipart.Add (attachment);\r\n\r\n// now set the multipart/mixed as the message body\r\nmessage.Body = multipart;\r\n```\r\n\r\n### Creating a Message Using a BodyBuilder (not Arnold Schwarzenegger)\r\n\r\nIf you are used to System.Net.Mail's API for creating messages, you will probably find using a `BodyBuilder`\r\nmuch more friendly than manually creating the tree of MIME parts. Here's how you could create a message body\r\nusing a `BodyBuilder`:\r\n\r\n```csharp\r\nvar message = new MimeMessage ();\r\nmessage.From.Add (new MailboxAddress (\"Joey\", \"joey@friends.com\"));\r\nmessage.To.Add (new MailboxAddress (\"Alice\", \"alice@wonderland.com\"));\r\nmessage.Subject = \"How you doin?\";\r\n\r\nvar builder = new BodyBuilder ();\r\n\r\n// Set the plain-text version of the message text\r\nbuilder.TextBody = @\"Hey Alice,\r\n\r\nWhat are you up to this weekend? Monica is throwing one of her parties on\r\nSaturday and I was hoping you could make it.\r\n\r\nWill you be my +1?\r\n\r\n-- Joey\r\n\";\r\n\r\n// Set the html version of the message text\r\nbuilder.HtmlBody = @\"<p>Hey Alice,<br>\r\n<p>What are you up to this weekend? Monica is throwing one of her parties on\r\nSaturday and I was hoping you could make it.<br>\r\n<p>Will you be my +1?<br>\r\n<p>-- Joey<br>\r\n<center><img src=\"\"sexy-pose.jpg\"\"></center>\";\r\n\r\n// Since sexy-pose.jpg is referenced from the html text, we'll need to add it\r\n// to builder.LinkedResources\r\nbuilder.LinkedResources.Add (\"C:\\\\Users\\\\Joey\\\\Documents\\\\SexySelfies\\\\sexy-pose.jpg\");\r\n\r\n// We may also want to attach a calendar event for Monica's party...\r\nbuilder.Attachments.Add (\"C:\\\\Users\\Joey\\\\Documents\\\\party.ics\");\r\n\r\n// Now we just need to set the message body and we're done\r\nmessage.Body = builder.ToMessageBody ();\r\n```\r\n\r\n### Preparing to use MimeKit's S/MIME support\r\n\r\nBefore you can begin using MimeKit's S/MIME support, you will need to decide which\r\ndatabase to use for certificate storage.\r\n\r\nIf you are targetting any of the Xamarin platforms (or Linux), you won't need to do\r\nanything (although you certianly can if you want to) because, by default, I've\r\nconfigured MimeKit to use the Mono.Data.Sqlite binding to SQLite.\r\n\r\nIf you are, however, on any of the Windows platforms, you'll need to pick a System.Data\r\nprovider such as [System.Data.SQLite](https://www.nuget.org/packages/System.Data.SQLite).\r\nOnce you've made your choice and installed it (via NuGet or however), you'll need to\r\nimplement your own `SecureMimeContext` class. Luckily, it's very simple to do. Assuming\r\nyou've chosen System.Data.SQLite, here's how you'd implement your own `SecureMimeContext`\r\nclass:\r\n\r\n```csharp\r\nusing System.Data.SQLite;\r\nusing MimeKit.Cryptography;\r\n\r\nusing MyAppNamespace {\r\n    class MySecureMimeContext : DefaultSecureMimeContext\r\n    {\r\n        public MySecureMimeContext () : base (OpenDatabase (\"C:\\\\wherever\\\\certdb.sqlite\"))\r\n        {\r\n        }\r\n\r\n        static IX509CertificateDatabase OpenDatabase (string fileName)\r\n        {\r\n            var builder = new SQLiteConnectionStringBuilder ();\r\n            builder.DateTimeFormat = SQLiteDateFormats.Ticks;\r\n            builder.DataSource = fileName;\r\n\r\n            if (!File.Exists (fileName))\r\n                SQLiteConnection.CreateFile (fileName);\r\n\r\n            var sqlite = new SQLiteConnection (builder.ConnectionString);\r\n            sqlite.Open ();\r\n\r\n            return new SqliteCertificateDatabase (sqlite, \"password\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nNow that you've implemented your own `SecureMimeContext`, you'll want to register it with MimeKit:\r\n\r\n```csharp\r\nCryptographyContext.Register (typeof (MySecureMimeContext));\r\n```\r\n\r\nNow you are ready to encrypt, decrypt, sign and verify S/MIME messages!\r\n\r\n### Preparing to use MimeKit's PGP/MIME support\r\n\r\nLike with S/MIME support, you also need to register your own `OpenPgpContext`. Unlike S/MIME, however,\r\nyou don't need to choose a database if you subclass `GnuPGContext` because it uses GnuPG's PGP keyrings\r\nto load and store public and private keys. If you choose to subclass `GnuPGContext`, the only thing you\r\nyou need to do is implement a password callback method:\r\n\r\n```csharp\r\nusing MimeKit.Cryptography;\r\n\r\nnamespace MyAppNamespace {\r\n    class MyGnuPGContext : GnuPGContext\r\n    {\r\n        public MyGnuPgContext () : base ()\r\n        {\r\n        }\r\n\r\n        protected override string GetPasswordForKey (PgpSecretKey key)\r\n        {\r\n            // prompt the user (or a secure password cache) for the password for the specified secret key.\r\n            return \"password\";\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOnce again, to register your `OpenPgpContext`, you can use the following code snippet:\r\n\r\n```csharp\r\nCryptographyContext.Register (typeof (MyGnuPGContext));\r\n```\r\n\r\nNow you are ready to encrypt, decrypt, sign and verify PGP/MIME messages!\r\n\r\n### Encrypting Messages with S/MIME\r\n\r\nS/MIME uses an application/pkcs7-mime MIME part to encapsulate encrypted content (as well as other things).\r\n\r\n```csharp\r\nvar joey = new MailboxAddress (\"Joey\", \"joey@friends.com\");\r\nvar alice = new MailboxAddress (\"Alice\", \"alice@wonderland.com\");\r\n\r\nvar message = new MimeMessage ();\r\nmessage.From.Add (joey);\r\nmessage.To.Add (alice);\r\nmessage.Subject = \"How you doin?\";\r\n\r\n// create our message body (perhaps a multipart/mixed with the message text and some\r\n// image attachments, for example)\r\nvar body = CreateMessageBody ();\r\n\r\n// now to encrypt our message body using our custom S/MIME cryptography context\r\nusing (var ctx = new MySecureMimeContext ()) {\r\n    // Note: this assumes that \"Alice\" has an S/MIME certificate with an X.509\r\n    // Subject Email identifier that matches her email address. If she doesn't,\r\n    // try using a SecureMailboxAddress which allows you to specify the\r\n    // fingerprint of her certificate to use for lookups.\r\n    message.Body = ApplicationPkcs7Mime.Encrypt (ctx, message.To.Mailboxes, body);\r\n}\r\n```\r\n\r\n### Decrypting S/MIME Messages\r\n\r\nAs mentioned earlier, S/MIME uses an application/pkcs7-mime part with an \"smime-type\" parameter with a value of\r\n\"enveloped-data\" to encapsulate the encrypted content.\r\n\r\nThe first thing you must do is find the ApplicationPkcs7Mime part (see the section on traversing MIME parts).\r\n\r\n```csharp\r\nif (entity is ApplicationPkcs7Mime) {\r\n    var pkcs7 = (ApplicationPkcs7Mime) entity;\r\n\r\n    if (pkcs7.SecureMimeType == SecureMimeType.EnvelopedData)\r\n        return pkcs7.Decrypt ();\r\n}\r\n```\r\n\r\n### Encrypting Messages with PGP/MIME\r\n\r\nUnlike S/MIME, PGP/MIME uses multipart/encrypted to encapsulate its encrypted data.\r\n\r\n```csharp\r\nvar joey = new MailboxAddress (\"Joey\", \"joey@friends.com\");\r\nvar alice = new MailboxAddress (\"Alice\", \"alice@wonderland.com\");\r\n\r\nvar message = new MimeMessage ();\r\nmessage.From.Add (joey);\r\nmessage.To.Add (alice);\r\nmessage.Subject = \"How you doin?\";\r\n\r\n// create our message body (perhaps a multipart/mixed with the message text and some\r\n// image attachments, for example)\r\nvar body = CreateMessageBody ();\r\n\r\n// now to encrypt our message body using our custom PGP/MIME cryptography context\r\nusing (var ctx = new MyGnuPGContext ()) {\r\n    // Note: this assumes that \"Alice\" has a public PGP key that matches her email\r\n    // address. If she doesn't, try using a SecureMailboxAddress which allows you\r\n    // to specify the fingerprint of her public PGP key to use for lookups.\r\n    message.Body = MultipartEncrypted.Create (ctx, message.To.Mailboxes, body);\r\n}\r\n```\r\n\r\n### Decrypting PGP/MIME Messages\r\n\r\nAs mentioned earlier, PGP/MIME uses a multipart/encrypted part to encapsulate the encrypted content.\r\n\r\nA multipart/encrtpted contains exactly 2 parts: the first `MimeEntity` is the version information while the\r\nsecond `MimeEntity` is the actual encrypted content and will typically be an application/octet-stream.\r\n\r\nThe first thing you must do is find the `MultipartEncrypted` part (see the section on traversing MIME parts).\r\n\r\n```csharp\r\nif (entity is MultipartEncrypted) {\r\n    var encrypted = (MultipartEncrypted) entity;\r\n\r\n    return encrypted.Decrypt ();\r\n}\r\n```\r\n\r\n### Digitally Signing Messages with S/MIME or PGP/MIME\r\n\r\nBoth S/MIME and PGP/MIME use a multipart/signed to contain the signed content and the detached signature data.\r\n\r\nHere's how you might digitally sign a message using S/MIME:\r\n\r\n```csharp\r\nvar joey = new MailboxAddress (\"Joey\", \"joey@friends.com\");\r\nvar alice = new MailboxAddress (\"Alice\", \"alice@wonderland.com\");\r\n\r\nvar message = new MimeMessage ();\r\nmessage.From.Add (joey);\r\nmessage.To.Add (alice);\r\nmessage.Subject = \"How you doin?\";\r\n\r\n// create our message body (perhaps a multipart/mixed with the message text and some\r\n// image attachments, for example)\r\nvar body = CreateMessageBody ();\r\n\r\n// now to digitally sign our message body using our custom S/MIME cryptography context\r\nusing (var ctx = new MySecureMimeContext ()) {\r\n    // Note: this assumes that \"Joey\" has an S/MIME signing certificate and private key\r\n    // with an X.509 Subject Email identifier that matches Joey's email address.\r\n    message.Body = MultipartSigned.Create (ctx, joey, DigestAlgorithm.Sha1, body);\r\n}\r\n```\r\n\r\nFor S/MIME, if you have a way for the user to configure which S/MIME certificate to use\r\nas their signing certificate, you could also do something more like this:\r\n\r\n```csharp\r\n// now to digitally sign our message body using our custom S/MIME cryptography context\r\nusing (var ctx = new MySecureMimeContext ()) {\r\n    var certificate = GetJoeysX509Certificate ();\r\n    var signer = new CmsSigner (certificate);\r\n    signer.DigestAlgorithm = DigestAlgorithm.Sha1;\r\n\r\n    message.Body = MultipartSigned.Create (ctx, signer, body);\r\n}\r\n```\r\n\r\nIf you'd prefer to use PGP instead of S/MIME, things work almost exactly the same except that you\r\nwould use an OpenPGP cryptography context. For example, you might use a subclass of the\r\n`GnuPGContext` that comes with MimeKit if you want to re-use the user's GnuPG keyrings (you can't\r\nuse `GnuPGContext` directly because it has no way of prompting the user for their passphrase).\r\n\r\nFor the sake of this example, let's pretend that you've written a minimal subclass of\r\n`MimeKit.Cryptography.GnuPGContext` that simply overrides the `GetPassword()` method and\r\nthat this subclass is called `MyGnuPGContext`.\r\n\r\n```csharp\r\n// now to digitally sign our message body using our custom OpenPGP cryptography context\r\nusing (var ctx = new MyGnuPGContext ()) {\r\n    // Note: this assumes that \"Joey\" has a PGP key that matches his email address.\r\n    message.Body = MultipartSigned.Create (ctx, joey, DigestAlgorithm.Sha1, body);\r\n}\r\n```\r\n\r\nJust like S/MIME, however, you can also do your own PGP key lookups instead of\r\nrelying on email addresses to match up with the user's private key.\r\n\r\n```csharp\r\n// now to digitally sign our message body using our custom OpenPGP cryptography context\r\nusing (var ctx = new MyGnuPGContext ()) {\r\n    var key = GetJoeysPrivatePgpKey ();\r\n    message.Body = MultipartSigned.Create (ctx, key, DigestAlgorithm.Sha1, body);\r\n}\r\n```\r\n\r\n### Verifying S/MIME and PGP/MIME Digital Signatures\r\n\r\nAs mentioned earlier, both S/MIME and PGP/MIME typically use a multipart/signed part to contain the\r\nsigned content and the detached signature data.\r\n\r\nA multipart/signed contains exactly 2 parts: the first `MimeEntity` is the signed content while the second\r\n`MimeEntity` is the detached signature and, by default, will either be an `ApplicationPgpSignature` part or\r\nan `ApplicationPkcs7Signature` part (depending on whether the sending client signed using OpenPGP or S/MIME).\r\n\r\nBecause the multipart/signed part may have been signed by multiple signers, it is important to\r\nverify each of the digital signatures (one for each signer) that are returned by the\r\n`MultipartSigned.Verify()` method:\r\n\r\n```csharp\r\nif (entity is MultipartSigned) {\r\n    var signed = (MultipartSigned) entity;\r\n\r\n    foreach (var signature in signed.Verify ()) {\r\n        try {\r\n            bool valid = signature.Verify ();\r\n\r\n            // If valid is true, then it signifies that the signed content has not been\r\n            // modified since this particular signer signed the content.\r\n            //\r\n            // However, if it is false, then it indicates that the signed content has\r\n            // been modified.\r\n        } catch (DigitalSignatureVerifyException) {\r\n            // There was an error verifying the signature.\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIt should be noted, however, that while most S/MIME clients will use the preferred multipart/signed\r\napproach, it is possible that you may encounter an application/pkcs7-mime part with an \"smime-type\"\r\nparameter set to \"signed-data\". Luckily, MimeKit can handle this format as well:\r\n\r\n```csharp\r\nif (entity is ApplicationPkcs7Mime) {\r\n    var pkcs7 = (ApplicationPkcs7Mime) entity;\r\n\r\n    if (pkcs7.SecureMimeType == SecureMimeType.SignedData) {\r\n        // extract the original content and get a list of signatures\r\n        MimeEntity extracted;\r\n\r\n        // Note: if you are rendering the message, you'll want to render the\r\n        // extracted mime part rather than the application/pkcs7-mime part.\r\n        foreach (var signature in pkcs7.Verify (out extracted)) {\r\n            try {\r\n                bool valid = signature.Verify ();\r\n\r\n                // If valid is true, then it signifies that the signed content has not\r\n                // been modified since this particular signer signed the content.\r\n                //\r\n                // However, if it is false, then it indicates that the signed content\r\n                // has been modified.\r\n            } catch (DigitalSignatureVerifyException) {\r\n                // There was an error verifying the signature.\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Contributing\r\n\r\nThe first thing you'll need to do is fork MimeKit to your own GitHub repository. Once you do that,\r\n\r\n    git clone git@github.com/<your-account>/MimeKit.git\r\n\r\nIf you use [Xamarin Studio](http://xamarin.com/studio) or [MonoDevelop](http://monodevelop.com), all of the\r\nsolution files are configured with the coding style used by MimeKit. If you use Visual Studio or some\r\nother editor, please try to maintain the existing coding style as best as you can.\r\n\r\nOnce you've got some changes that you'd like to submit upstream to the official MimeKit repository,\r\nsimply send me a Pull Request and I will try to review your changes in a timely manner.\r\n\r\nIf you'd like to contribute but don't have any particular features in mind to work on, check out the issue\r\ntracker and look for something that might pique your interest!\r\n\r\n## Reporting Bugs\r\n\r\nHave a bug or a feature request? [Please open a new issue](https://github.com/jstedfast/MimeKit/issues).\r\n\r\nBefore opening a new issue, please search for existing issues to avoid submitting duplicates.\r\n\r\n## Documentation\r\n\r\nAPI documentation can be found at [http://jstedfast.github.io/MimeKit/docs](http://jstedfast.github.io/MimeKit/docs).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}